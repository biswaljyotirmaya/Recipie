package com.jb.service;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import com.fasterxml.jackson.core.json.JsonReadFeature;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.json.JsonMapper;

import jakarta.annotation.PostConstruct;

@Service
public class RecipeService {

    private static final Logger logger = LoggerFactory.getLogger(RecipeService.class);
    private static final String COLLECTION_NAME = "recipes";
    
    @Autowired
    private MongoTemplate mongoTemplate;
    
    private final ObjectMapper objectMapper = JsonMapper.builder()
            .enable(JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS)
            .build();

    @PostConstruct
    public void loadRecipes() {
        if (isCollectionPopulated()) {
            logger.info("Recipes already loaded. Skipping initialization.");
            return;
        }

        readRecipesFromJson("/US_recipes.json").stream()
                .filter(Objects::nonNull)
                .forEach(this::sanitizeRecipe);
                
        logger.info("Loaded recipes successfully.");
    }

    private boolean isCollectionPopulated() {
        return mongoTemplate.collectionExists(COLLECTION_NAME) && 
               mongoTemplate.estimatedCount(COLLECTION_NAME) > 0;
    }

    private List<Map<String, Object>> readRecipesFromJson(String path) {
        try (InputStream is = getClass().getResourceAsStream(path)) {
            if (is == null) {
                logger.warn("JSON file '{}' not found in resources!", path);
                return Collections.emptyList();
            }

            JsonNode rootNode = objectMapper.readTree(is);
            List<Map<String, Object>> recipes = new ArrayList<>();
            
            rootNode.fields().forEachRemaining(entry -> {
                JsonNode recipeNode = entry.getValue();
                if (recipeNode.isObject()) {
                    Map<String, Object> recipeMap = objectMapper.convertValue(
                        recipeNode, new TypeReference<Map<String, Object>>() {});
                    recipes.add(recipeMap);
                }
            });
            
            mongoTemplate.insert(recipes, COLLECTION_NAME);
            return recipes;
            
        } catch (Exception e) {
            logger.error("Failed to read recipes JSON from path: {}", path, e);
            return Collections.emptyList();
        }
    }

    private void sanitizeRecipe(Map<String, Object> recipe) {
        if (recipe == null) return;

        // Clean rating
        Optional.ofNullable(recipe.get("rating"))
                .filter(Number.class::isInstance)
                .map(Number.class::cast)
                .map(Number::doubleValue)
                .filter(r -> !Double.isNaN(r) && !Double.isInfinite(r))
                .orElseGet(() -> {
                    recipe.put("rating", null);
                    return null;
                });

        // Clean negative times
        Arrays.asList("prep_time", "cook_time", "total_time")
                .forEach(field -> cleanNegativeTime(recipe, field));

        // Handle nutrients
        Object nutrients = recipe.computeIfAbsent("nutrients", k -> new HashMap<String, Object>());
        if (!(nutrients instanceof Map)) {
            recipe.put("nutrients", new HashMap<String, Object>());
        }

        parseCalories(recipe);
    }

    private void cleanNegativeTime(Map<String, Object> recipe, String timeField) {
        Optional.ofNullable(recipe.get(timeField))
                .filter(Number.class::isInstance)
                .map(Number.class::cast)
                .map(Number::intValue)
                .filter(time -> time < 0)
                .ifPresent(time -> recipe.put(timeField, null));
    }

    private void parseCalories(Map<String, Object> recipe) {
        Optional.ofNullable(recipe.get("nutrients"))
                .filter(Map.class::isInstance)
                .map(Map.class::cast)
                .map(nutrients -> nutrients.get("calories"))
                .filter(String.class::isInstance)
                .map(String.class::cast)
                .filter(caloriesStr -> caloriesStr.endsWith(" kcal"))
                .ifPresent(caloriesStr -> {
                    try {
                        float caloriesValue = Float.parseFloat(caloriesStr.replace(" kcal", "").trim());
                        recipe.put("calories", caloriesValue);
                    } catch (NumberFormatException e) {
                        recipe.put("calories", null);
                        logger.debug("Failed to parse calories: {}", caloriesStr);
                    }
                });
    }

    public Page<Map<String, Object>> getAllRecipes(int page, int limit) {
        return executePagedQuery(new Query(), page, limit);
    }

    public Page<Map<String, Object>> searchRecipes(String title, String cuisine, Float minRating, Float maxRating,
            Integer maxTotalTime, Float maxCalories, int page, int limit) {

        Criteria criteria = new Criteria();
        List<Criteria> criteriaList = new ArrayList<>();

        if (StringUtils.hasText(title))
            criteriaList.add(Criteria.where("title").regex(title, "i"));
        
        if (StringUtils.hasText(cuisine))
            criteriaList.add(Criteria.where("cuisine").is(cuisine));
        
        if (minRating != null)
            criteriaList.add(Criteria.where("rating").gte(minRating));
        
        if (maxRating != null)
            criteriaList.add(Criteria.where("rating").lte(maxRating));
        
        if (maxTotalTime != null)
            criteriaList.add(Criteria.where("total_time").lte(maxTotalTime));
        
        if (maxCalories != null)
            criteriaList.add(Criteria.where("calories").lte(maxCalories));

        if (!criteriaList.isEmpty()) {
            criteria.andOperator(criteriaList.toArray(new Criteria[0]));
        }

        return executePagedQuery(Query.query(criteria), page, limit);
    }

    private Page<Map<String, Object>> executePagedQuery(Query query, int page, int limit) {
        try {
            Pageable pageable = createPageRequest(page, limit);
            long total = mongoTemplate.count(query, COLLECTION_NAME);
            List<Map<String, Object>> content = mongoTemplate.find(query.with(pageable), Map.class, COLLECTION_NAME);
            
            return new PageImpl<>(content, pageable, total);
        } catch (Exception e) {
            logger.error("Error executing query", e);
            return Page.empty();
        }
    }

    private Pageable createPageRequest(int page, int limit) {
        return PageRequest.of(
            Math.max(0, page - 1), 
            Math.max(1, limit), 
            Sort.by("rating").descending().and(Sort.by("title"))
        );
    }

    // Additional utility methods
    public Map<String, Object> findById(String id) {
        return mongoTemplate.findOne(Query.query(Criteria.where("_id").is(id)), 
                                   Map.class, COLLECTION_NAME);
    }

    public List<String> findAllCuisines() {
        try {
            return mongoTemplate.query(Map.class)
                .inCollection(COLLECTION_NAME)
                .distinct("cuisine")
                .as(String.class)
                .all();
        } catch (Exception e) {
            logger.error("Error fetching cuisines", e);
            return Collections.emptyList();
        }
    }

    public List<String> findAllFields() {
        return Optional.ofNullable(mongoTemplate.findOne(new Query().limit(1), 
                                                       Map.class, COLLECTION_NAME))
                .map(Map::keySet)
                .map(ArrayList::new)
                .orElseGet(ArrayList::new);
    }

    public long getTotalRecipeCount() {
        try {
            return mongoTemplate.estimatedCount(COLLECTION_NAME);
        } catch (Exception e) {
            logger.error("Error counting recipes", e);
            return 0;
        }
    }

    public List<Map<String, Object>> findByField(String fieldName, Object value) {
        return mongoTemplate.find(Query.query(Criteria.where(fieldName).is(value)), 
                                Map.class, COLLECTION_NAME);
    }

    public List<Map<String, Object>> findByFieldRegex(String fieldName, String regex) {
        return mongoTemplate.find(Query.query(Criteria.where(fieldName).regex(regex, "i")), 
                                Map.class, COLLECTION_NAME);
    }
}